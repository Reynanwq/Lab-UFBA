ARVORES VERMELHA E PRETA OU ARVORE RUBRO NEGRAS.

link's vermelhos sempre à esquerda.
altura negra: quantidade de link's negros que nós utilizamos para passar um NÓ
NÃO PODE TER 2 LINK'S rubros em seguida

VANTAGENS: todos os algoritmos usados em arvores de busca também podem ser usados em árvores rubro-negras
dizer se o link para esquerda ou o link para a direita é vermelho ou preto
a chegada do link vermelho será o NÓ vermelho.

Todo nó da arvore é "vermelho" ou "preto".
A raiz é sempre preta.
Todo Nó folha NULL é "preto".
se um NÓ é "vermelho", então os seus filhos são "pretos".

AVL vs VP

AVL: mais rápida no processo de busca
VP: mais rápida no processo de remoção e inserção

TAD

typedef enmu{
  C_RED,
  C_BLACK;
}ARN_COR;

typedef struct ARN{
  struct ARN *left;
  struct ARN *right;
  int valor;
  int chave;
  ARN_COR cor;
}ARN;

static ARN *ARN_Criar(int chave, int valor){
  ARN* novo;
  novo = malloc(sizeof(ARN));
  novo->chave = chave;
  novo->valor = valor;
  novo->cor = C_VERMELHO;
  novo->left = NULL;
  novo->right = NULL;
  
  return novo;
}

static inline int eh_vermelho(ARN *A){
  if(A == NULL){
    return 0;
   } return A->cor == C_VERMELHO ? 1 : 0;
}

static void inverter_cores(ARN *A){
  A->cor = C_VERMELHO;
  A->left->cor = C_PRETO;
  A->right->cor = C_PRETO;
}

static void rot_left(ARN **A){
  ARN *h, *x;
  h = *A;
  x = h->right;
  h->right = x->left;
  x->left = h;
  x ->cor = h->cor;
  h->cor = C_VERMELHO;
  *A = x;
}

static void rot_right(ARN **A){
  ARN *h, *x;
  h = *A;
  x = h->left;
  h->letf = x->right;
  x->right = h;
  x ->cor = h->cor;
  h->cor = C_VERMELHO;
  *A = x;
}



void ARN_inserir_R(ARN **A, int chave, int valor){
  if(*A == NULL){
    *A = ARN_Criar(chave, valor);
    return;
  }
  if(chave < (*A)->chave){
    ARN_Inserir_R(&(*A)->left, chave, valor);
  }
  if(chave > (*A)->chave){
   ARN_Inserir_R(&(*A)->right, chave, valor);
  }
  
  if(eh_vermelho((*A)->right && !eh_vermelho((*A)->left)){
    rot_left(A);
  }
  
  if(eh_vermelho((*A)->left && eh_vermelho((*A)->left->left)){
    rot_right(A);
  }
  
  if(eh_vermelho((*A)->left && eh_vermelho((*A)->right)){
    inverter_cores(*A);
  }
  
} 

void ARN_inserir(ARN **A, int chave, int valor){
  ARN_inserir_R(A, chave, valor);
}
































































































